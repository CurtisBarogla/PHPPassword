<?php
//StrictType
declare(strict_types = 1);

/*
 * Zoe
 * Password component
 *
 * Author CurtisBarogla <curtis_barogla@outlook.fr>
 *
 */

namespace Zoe\Component\Password\Topology;

/**
 * Collection of PasswordTopology.
 * A collection can only handle a single generator.
 * Registering a topology generated by a different generator which previous topologies has been generator will result an exception
 * 
 * @author CurtisBarogla <curtis_barogla@outlook.fr>
 *
 */
class PasswordTopologyCollection implements \ArrayAccess, \Countable, \IteratorAggregate
{
    
    /**
     * Topologies into the collection
     * 
     * @var PasswordTopology[]
     */
    private $topologies = [];
    
    /**
     * Generator identifier
     * 
     * @var string
     */
    private $generator;
    
    /**
     * Current index stored from a previous isset call
     * Use for getting a topology when a string is given to offsetGet
     * 
     * @var int
     */
    private $current;
    
    /**
     * {@inheritDoc}
     * @see \IteratorAggregate::getIterator()
     */
    public function getIterator(): \Generator
    {
        foreach ($this->topologies as $topology)
            yield $topology;
    }
    
    /**
     * {@inheritDoc}
     * @see \ArrayAccess::offsetExists()
     */
    public function offsetExists($offset): bool
    {
        if(\is_string($offset)) {
            foreach ($this->topologies as $index => $topology) {
                if($topology->getTopology() === $offset) {
                    $this->current = $index;
                    
                    return true;
                }
            }
            
            return false;
        }
            
        return isset($this->topologies[$offset]);
    }
    
    /**
     * {@inheritDoc}
     * @see \ArrayAccess::offsetGet()
     */
    public function offsetGet($offset): PasswordTopology
    {
        if(\is_string($offset)) {
            if($this->offsetExists($offset))
                return $this->topologies[$this->current];
        }
        
        return $this->topologies[$offset];
    }

    /**
     * @throws \InvalidArgumentException
     *   When given value is not an instance of PasswordTopology
     * @throws \LogicException
     *   When given topology if from a different generator than previously registered ones
     * 
     * {@inheritDoc}
     * @see \ArrayAccess::offsetSet()
     */
    public function offsetSet($offset, $value): void
    {
        if(!$value instanceof PasswordTopology)
            throw new \InvalidArgumentException("Value setted into a PasswordTopologyCollection MUST be an instance of PasswordTopology");
        
        if(null !== $this->generator && $this->generator !== $value->generatedBy())
            throw new \LogicException(\sprintf("Cannot register this topology into this collection. Reserved to '%s' generator identifier ; '%s' generator given",
                $this->generator,
                $value->generatedBy()));
        
        if(\in_array($value, $this->topologies, true))
            return;

        if(null === $this->generator)
            $this->generator = $value->generatedBy();
            
        $this->topologies[] = $value;
    }

    /**
     * {@inheritDoc}
     * @see \ArrayAccess::offsetUnset()
     */
    public function offsetUnset($offset): void
    {
        if(\is_string($offset)) {
            if($this->offsetExists($offset))
                unset($this->topologies[$this->current]);
        }
        
        unset($this->topologies[$offset]);
    }

    /**
     * {@inheritDoc}
     * @see \Countable::count()
     */
    public function count(): int
    {
        return \count($this->topologies);
    }
    
    /**
     * Merge this collection with an another
     * 
     * @param PasswordTopologyCollection $collection
     *   Collection to merge
     * 
     * @throws \InvalidArgumentException
     *   When generator identifier does not correspond with the current one
     */
    public function merge(PasswordTopologyCollection $collection): void
    {
        if(null === $this->generator)
            $this->generator = $collection->getCollectionGeneratorIdentifier();
        
        if($collection->getCollectionGeneratorIdentifier() !== $this->generator)
            throw new \InvalidArgumentException(\sprintf("Cannot merge collection composed of topologies generated with '%s' generator with '%s' generator",
                $collection->getCollectionGeneratorIdentifier(),
                $this->generator));
            
        foreach ($collection as $topology)
            $this[] = $topology;
    }
    
    /**
     * Extract values from the current topology and return it as a new collection
     * 
     * @param int $limit
     *   Limit of topologies to extract
     * 
     * @return PasswordTopologyCollection
     *   New collection setted with extracted topologies
     */
    public function extract(int $limit): PasswordTopologyCollection
    {
        $topologies = \array_slice($this->topologies, 0, $limit);
        
        $collection = new self;
        $collection->topologies = $topologies;
        $collection->generator = $this->generator;
        
        return $collection;
    }
    
    /**
     * Get generator identifer which topologies are generated with
     * 
     * @return string
     *   Generator identifier
     * 
     * @throws \BadMethodCallException
     *   When collection is empty and not generator has been setted
     */
    public function getCollectionGeneratorIdentifier(): string
    {
        if(null === $this->generator)
            throw new \BadMethodCallException("Cannot get a generator identifier from an empty PasswordTopologyCollection");
        
        return $this->generator;
    }
    
}
